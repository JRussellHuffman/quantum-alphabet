import processing.svg.*;

PFont f;                           
int numPixels;  
int colorcounter = 0;
int correctCount = 0;
String[] quantumCorpusLoad;
String[] finalQuantumArray;
String letterToRender = "A"; //the letter to draw, and the data to pull. all the data with this project was generated by the ibmq-paris quantum computer
String desiredValue;
int scale = 15;
int coreWidth = 100;
int coreHeight = 70;
  
void setup() {
  size(1500,1200); //need to be scaled witht he scale factor (at least the width does)
  f = createFont("IBMPlexSans-SemiBold",12,false);
  letterToBinaryString(letterToRender);
  //beginRecord(SVG, letterToRender + ".svg"); //uncomment this and "endrecord()" to save as SVG
  background(255);
  textFont(f,48);
  fill(0);
  text(letterToRender,10,50);
  numPixels = coreWidth*coreHeight;
  countPixels();
  coverTheStartingimage();
  
  //endRecord();
}


void countPixels() {
  loadPixels();
  float threshold = 255;
  parseCorpus();
  for (int i = 0; i < numPixels * scale; i++) { //canvas is now "scale" times the size of the initial canvas
     color a = pixels[i];
     
     
     if (red(a) < threshold) { // If the pixel is brighter than this
       replaceWithCircuitValue(i);
       colorcounter++;
     }  
   
  }
   println("total pixels to color: " + colorcounter);
   println("total correct: " + correctCount);
}

void replaceWithCircuitValue(int i) {
      double ycoordinate = Math.floor(i/(coreWidth * scale));
      double xcoordinate = i - (ycoordinate*width);
       //convert to 
      float x = (float) xcoordinate;
      float y = (float) ycoordinate;
      
      noFill();
      
      int binaryToInt = Integer.parseInt(finalQuantumArray[colorcounter], 2);
      
      
      
      
    
    if (finalQuantumArray[colorcounter].equals(desiredValue)){
       stroke(0);
       strokeWeight(2);
       rect(x*scale, y*scale, ceil(binaryToInt/10), ceil(binaryToInt/10)); //the 10 here is to scale down the value
       correctCount++;
    } else {
      
      stroke(150);
      strokeWeight(0.5);
      
      color gray = #878D96;
      stroke(gray);
      
      //any time the "binaryToInt variable is divided by a value, that is an artistic decision to scale the value
      
      //squares
      rect(x*scale, y*scale, ceil(binaryToInt/10), ceil(binaryToInt/10));
      
      //circles
      //circle(x*scale, y*scale, ceil(binaryToInt/2));
      
      //actual triangle
      //triangle(x*scale, y*scale, (x*scale) + (binaryToInt/2), (y*scale), (x*scale), (y*scale) + (binaryToInt/2));
      
      //diagnal line
      //line(x*scale, y*scale, (x*scale) + (binaryToInt), (y*scale)+ (binaryToInt));
      
      //other diagonal line
      //line(x*scale, y*scale, (x*scale) - (binaryToInt), (y*scale) + (binaryToInt));
      
      //horizontal line
      //line(x*scale, y*scale, (x*scale) + (binaryToInt), (y*scale));
      
      //vertical line
      //line(x*scale, y*scale, (x*scale), (y*scale) + (binaryToInt));
      
      
      
      //triangle thing
      //line(x*scale, y*scale, (x*scale) + (binaryToInt/2), (y*scale));
      //line(x*scale, y*scale, (x*scale), (y*scale) + (binaryToInt/10));
      //line(x*scale, y*scale, (x*scale) - (binaryToInt/2), (y*scale) + (binaryToInt/2));
      
      
      //star is actually a hexagon
      //star(x*scale, y*scale, (binaryToInt/2), (binaryToInt/2), 3); 
      
      
    }
}

void star(float x, float y, float radius1, float radius2, int npoints) {
  float angle = TWO_PI / npoints;
  float halfAngle = angle/2.0;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    float sx = x + cos(a) * radius2;
    float sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a+halfAngle) * radius1;
    sy = y + sin(a+halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

void parseCorpus() {
  quantumCorpusLoad = loadStrings(letterToRender + ".txt");
  finalQuantumArray = quantumCorpusLoad[0].replaceAll("\\[", "").replaceAll("\\]", "").replaceAll("\\s", "").replaceAll("'", "").split(",");
}

void coverTheStartingimage () {
  fill(255);
  stroke(255);
  rect(0, 0, coreWidth, coreHeight);
}

void letterToBinaryString(String letter) {
  
  //this is the best way I could figure out how to convert our letter to its binary representation...
  char letterAsInt = letter.charAt(0);
  int num = letterAsInt;
  println("letter as int is " + num);
  desiredValue = Integer.toBinaryString(num);
  println("desired value is " + desiredValue);
}
